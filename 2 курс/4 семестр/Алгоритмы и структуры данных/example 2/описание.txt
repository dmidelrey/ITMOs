1401 - Игроки
Основной подход состоит в том, чтобы поделить текущую задачу на 4 подзадачи и соответственно 4 раза рекурсивно вызвать основную функцию. 
Основная суть в том, что мы делим каждый раз нашу задачу на 4. То есть делим поле на 4 части, пока размер одной такой части не будет 2 х 2. 
Сначала доходим до части, где стоит ноль, и зарисовываем остальные три точки. После (когда возвращаеся из квадрата 2 х 2 в исходный квадрат 4 х 4), 
зарисовываем три точки, в зависимости от того, где находился наш квадрат 2 х 2. Далее зарисовываем все остальные. 


1155 - Дуоны
Изначально проверка на неразрешимость задачи -  это может быть в том случае, если сумма edbg не равна afhc 
(все вершины из edbg могут взаимодействовать только с вершинами afhc. Соответственно допустим, что в edbg есть дуоны, а в efhc их нет. Следовательно задача не разрешима).
Далее пользуясь тем, что добавлять дуоны в случае необходимости выводим действия по удалению всех дуонов - для каждой вершины сначала рассматриваются смежные к ним 
(если в смежной еще есть дуоны - удаляем их), а после - противолежащая (если в ней есть дуоны, то аннигилируем дуонов в одном из ребер, чтобы позже удалить дуонов из двух ребер)


1207 - Медиана на плоскости
Сначала считываем точки в массив точек, одновременно находим "минимальную точку" - самую нижнюю и самую левую (строго - самая нижняя). 
Для всех точек из массива считаем тангенс угла между прямой, которая проходит через "минимальную точку" и текущую, и положительным направлением оси ОХ. 
Далее используя алгоритм сортировки слиянием сортируем все точки согласно тангенсу угла. В качестве результата выводим номера "минимальной точки" и 
номер точки из середины массива (т.к. последняя составляет "центральный угол", а значит, слева и справа от него лежат бОльшие и меньшие углы в равном
количестве).


1604 - В стране дураков
Сначала считываем количество различных знаков, после - количество знаков каждого номинала, вносим это количество в массив знаков, 
запоминая количество и индекс. Одновременно ищем наибольшее и наименьшее количество знаков. Пока массив содержит элементы, 
ищем пару знаков: наибольшее оставшееся количество знаков и наименьшее, возвращаем и выводим номера этих знаков.  Когда наступит ситуация,
что мы не смогли найти ни одного знака на итерации, значит, мы использовали все знако. Все знаки, что еще будут оставаться, будут выведены в конце.
Это значит, что количество знаков данного номинало превосходило количество всех остальных знаков.


1322 - Шпион
По последнему столбцу можно определить последню букву каждого слова, а также буквы, из которых эти слова состоят. Если отсортировать столбец
в лексиграфическом порядке, то мы получим первый столбец. Циклически сдвинув слова, получим уже 2 буквы слова.
Отсюда можно заключить, что, зная первую букву слова, можно определить букву стоящую передней, потом ещё одну, и так далее пока не соберётся всё слово.
Для того, чтобы узнать в какой строке следующая буква, пронумеруем буквы последнего столбца и выполним стабильную сортировку.
У нас ограниченный алфавит, поэтому можно применить сортировку подсчётом, которая будет выполнена за 2 прохода по алфавиту и 2 проходу 
по вспомогательному массиву, результаты занесём в "вектор переходов" t, который указывает на строку в которой хранится предыдущая буква.
Чтобы узнать в какой строке будет стоять буква достаточно знать, сколько других букв есть перед ней и сколько раз она уже встретилась в столбце.
За первый проход по столбцу мы подсчитываем, сколько и каких букв встретилось в строке.
// Например:
// rdarcaaaabb -> count {...a(5)b(2)c(1)d(1)...r(2)...}
Потом пробегаемся по вспомогательному массиву и для каждой буквы подсчитываем сколько букв перед ней. 
// В нашем случае
// count {...a(0)b(0+5)c(2+5)d(7+1)...r(8+1)...}
Далее опять пробегаемся по столбцу и составляем "вектор переходов" t*:
T[i] = count[s[i]] + Pi,
где 	count [s[i]] - количество для каждой буквы, которое встречаются в строке меньшие ее буквы, 
	Pi - количество раз, которое буква уже встретилась по столбцу.
После построения вектора переходов, начиная с конца слова и с (n-1) позиции вектора T, считываем слово с конца, вновь проходя по столбцу, и выводим его.


Задача 1604 - В стране дураков
Введем понятие «оптимального решения». Оптимальное решение – это такое решение, которое удовлетворяет условию о том, что в нем минимально количество подряд идущих знаков. Необходимо доказать, что в оптимальном решении последовательность одинаковых подряд идущих знаков только одна. Докажем «от противного»: в случае если бы таких последовательностей было 2 и больше, их можно было бы «перемешать» между собой, чтобы это решение удовлетворяло условию задачи. Например, последовательность
a b a b a b c c c d d d d
Можно было бы преобразовать в последовательность
a b a b a b c d c d c d d
где подряд идущих одинаковых знаков в разы меньше.
Вынесем эту последовательность подряд идущих одинаковых знаков в конец всей последовательности для удобства. Пускай количество знаков в максимальной группе будет X, количество всех элементов – N, количество всех остальных знаков кроме знаков X: Z = N – X.
Докажем, что если мы будем последовательно вынимать знак из максимума и минимума, то сможем построить оптимальное решение. Для доказательства рассмотрим «идеальное» решение – решение, в котором нет конца в виде подряд идущих одинаковых знаков. Для такого решения всегда выполняется свойство: X < Z + 1. Это справедливо, ведь если бы это условие не выполнялось, то вышло бы так, что это решение неидеально и в нем все еще есть конец из одинаковых знаков.
Рассмотрим исходную оптимальную последовательность. Отрежем ее конец из одинаковых знаков – приведем решение к «идеальному». Отсортируем их по количеству знаков в каждом номинале:
a >= b >= c >= … >= y >= z
Вынем один знак из a и один из z. Получим:
(a-1) >= b >= c >= … >= y >= (z-1)
Из выведенного условия для «идеальных» последовательностей получим, что
(a-1) < b + c + … + (z – 1) + 1
Продолжая вынимать из a и из z по одному знаку m раз, получим
(a-m) < b + c + … + (z – m) + 1
Предположим, что после m итераций это условие сохранялось, но на (m+1) итерации (a-m) перестало быть максимумом всей последовательности и им стало число b.  То есть для этих двух итераций будут выполнены условия:
(a-m) >= b           (1)
(a-m-1) < b         (2)
Докажем, что если :
(a-m) < b + c + … + (z – m) + 1
то выполняется и условие:
b < (a-m) + c + … + (z-m) + 1
Доказательство:  из (1) мы можем понять, что существует пограничный случай b = a – m, так как все числа целые и, более того, натуральные.
Значит, подставив (a-m) вместо b получим:
(a-m) < (a-m) + c + … + (z-m) +1
0 < c + … + (z-m) + 1
Очевидно, что сумма номиналов всех знаков больше нуля, так как количество знаков – число натуральное и не может быть меньше нуля. А это значит, что вынимая каждый раз минимум и максимум из массива знаков мы постепенно составляем «идеальное» решение. Для того, чтобы вернуться к исходному оптимальному решению, необходимо дописать в его конец усеченную изначально последовательность подряд идущих знаков одного номинала с наибольшим количеством.

 
Задача 1080 - Раскраска карты
В ходе программы:
1) считываем количество стран, а также граничащие страны с каждой страной.
2) первую страну красим в синий цвет
3) далее для каждой страны: при переходе в новую страну мы пытаемся ее покрасить в противоположный от предыдущей страны цвет. Если мы переходим в страну, которую уже покрасили, то проверяем, что мы перешли в другой цвет.
4) если не перешли, то покрасить невозможно и мы выводим -1
5) если дошли до конца и все хорошо, то выводим последовательность цветов для раскраски.
Вообще все эти действия - это алгоритм проверки графа на двудольность.


Задача 1162 - Currency Exchange
В ходе программы:
1) Считываем в переменные n, m, s, v соответственно количество валют, обменных пунктов, номер текущей валюты и сколько ее у Ника.
2) Считываем описание всех обменных пунктов
3) далее мы смотрим на каждый обменный пункт, и если с помощью него можно увеличить количество денег, даже несмотря на комиссию,  то осуществляем эту операцию.
4) если получилось увеличить количество денег, то выводим "YES", иначе "NO"


Задача 1450 - Российские газопроводы
В ходе программы:
1) считываем количество перекачивающих станций и газопроводов в переменные n, m.
2) далее для каждого газопровода считываем номера соединяющих станций и его прибыльность.
3) считываем номера первой и последней станции
3) далее проходим по каждому газопроводу и если получаем прибыль с помощью него, то увеличиваем всю выгоду на величину этой прибыли.
4) ну и если в итоге общая выгода стала больше 0, то мы выводим 
эту прибыль.
5) если же меньше 0, то пишем "No solution".
