/*	1296. КУЧА КАМНЕЙ

	АЛГОРИТМ: задача решается методом перебора. В основной функции сначала происходит проверка индекса - если он равен N,
то разбор одного из случаев закончен, и необходимо сравнить текущую разность между кучами с предыдущей и запомнить
минимальное из этих чисел. Если индекс меньше N, то происходит рассмотрение возможных случаев разложения - рекурсивно 
вызывается эта же функция для случая, когда следующий элемент будет положен в кучу 1, и для случая, когда следующий
элемент будет положен в кучу 2. Засчет этих рекурсивных вызовов происходит перебор всевозможных разложений.

	ОЦЕНКА ВРЕМЕНИ РАБОТЫ: для оценки сложности рекурсивного алгоритма построим дерево вызовов. Глубиной дерева будет являться (N+1),
т.к. каждый новый вызов происходит сувеличением индекса (i) с нуля до N. На k-ом уровне происходит (2^k * c) операций =>
всего операций (2^0 * c) + (2^1 * c) + ... + (2^N * c). Если вынести c за скобки, получится сумма геометрической прогрессии, равная
S = 2^(N+1) - 1. Согласно О-асимптотике можно сказать, что T(N) = O(2^N) */

#include <iostream>
#include <algorithm>
#include <limits>

using namespace std;

void heapDivide (int i, int s1, int s2);
int N;
int s;
int* A; 
int m = INT_MAX;

int main()
{
	cin >> N;

	A = new int[N];
	for (int i = 0; i < N; i++) {
		cin >> A[i];
		s += A[i];
	}

	heapDivide(0, 0, 0);
	cout << m;

	getchar();
	getchar();

    return 0;
}

void heapDivide (int i, int s1, int s2) {

	if(i == N) {
		m = min(m, abs(s1 - s2));
	}  else {
		heapDivide(i + 1, s1 + A[i], s2);
		heapDivide(i + 1, s1, s2 + A[i]);
	}

}